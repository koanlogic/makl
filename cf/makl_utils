#
# $Id: makl_utils,v 1.28 2006/05/18 14:16:44 stewy Exp $
#

##\brief Set the package name.
##
##  Set the package name to \e $1.
##
##  \param $1 package name
##  
makl_pkg_name ()
{
    [ $1 ] || makl_err 1 "makl_pkg_name(): undefined package name!"

    makl_info "setting package name to $1"

    makl_set "__package__" "$1"
}

##\brief Set the package version.
##
##  Set the package version to \e $1.
##  [format: "X.Y.Z", where X, Y and Z are digits]
##  If no argument is supplied, a file named VERSION in the base 
##  directory containing the version is expected. 
##  The package name must already be defined by \e makl_pkg_name().
##
##  \param $1 package version (optional)
##  
makl_pkg_version ()
{
    file="VERSION"
    pkg=`makl_get "__package__"`

    [ -z ${pkg} ] && \
        makl_err 1 "makl_pkg_version(): makl_pkg_name must be defined first!"

    [ -f ${file} ] && [ -r ${file} ] && \
        ver=`cat ${file} | sed 's/[\ 	]*$//'`	#remove trailing whitespace

    [ $? = 0 ] || ver=$1

    ${ECHO} ${ver} | grep '^[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$' 1> /dev/null
    [ $? = 0 ] || makl_err 2 "makl_pkg_version(): version must have format 'X.Y.Z'" \
						     "where X, Y and Z are digits."

    makl_set_var "`makl_upper ${pkg}`_VERSION" ${ver} 1

    makl_info "setting version to ${ver}"
}

##\brief Print the OS name.
## 
##  Print a brief string representing the operating system type and version.
##
makl_os_name ()
{
    uname -rs | tr '[A-Z]' '[a-z]' | sed -e 's/ //'
}

##\brief Print the target OS name.
## 
##  Print a brief string representing the target operating system type and 
##  version.
##
makl_target_name ()
{
    if [ -z "${MAKL_PLATFORM}" ];  then
        uname -rs | tr '[A-Z]' '[a-z]' | sed -e 's/ //'
    else
        echo "${MAKL_PLATFORM}" | tr '[A-Z]' '[a-z]' 
    fi
}

##\brief Write a message and exit.
##
##  Print the supplied error string to stderr and bail out with the given 
##  exit code.
## 
##   \param $1 exit code
##   \param $2 error string
##
makl_err ()
{
    exit_code=$1
    shift

    ${ECHO} 1>&2 "[err] $*"
    makl_cleanup_rundir
    exit ${exit_code}
}

## \brief Print info 
##
##   Print some basic info on MaKL operations.
##
##     \param $1 info string
##
makl_info ()
{
    ${ECHO} "$*"
}

##\brief Print a debug message. 
##
##  Print the supplied debug message to stderr if "makl_debug" variable is set
##  to "true", "yes", "on" or '1'.
##
##   \param $1 debug string
##
makl_dbg ()
{
    [ -z `makl_get "__verbose__"` ] || ${ECHO} 1>&2 "[dbg] $*"
}

##\brief Print a warning message.
##
##  Print the supplied warning message to stderr.
##  
##   \param $1 warning string
##
makl_warn ()
{
    ${ECHO} 1>&2 "[wrn] $*"
}

##\brief Print global variables.
##
##  Print MaKL global variables in use to stderr if 'makl_debug' is set.
##
makl_dbg_globals ()
{
    makl_dbg "MAKL_DIR: ${MAKL_DIR}"
    makl_dbg "makl_run_dir: ${makl_run_dir}"
    makl_dbg "makl_conf_h: ${makl_conf_h}"
    makl_dbg "makl_makefile_conf: ${makl_makefile_conf}"
}

##\brief Tool requirements check
##
##  Check existence of basic tool requirements.
##
##  \param $1 0 if tools don't use stdin, 1 otherwise
##  \param $@ list of tools
##
makl_check_tools ()
{
    has_stdin=0
    [ $1 -eq 0 ] || has_stdin=1
    shift
    
    for tool in "$@"; do
        if [ ${has_stdin} -eq 0 ]; then
            eval ${tool} 1> /dev/null 2> /dev/null
        else
            eval echo | ${tool} 1> /dev/null 2> /dev/null
        fi
        if [ $? = 127 ]; then
            ${ECHO} "required tool not found: ${tool}!"
            exit 2
        fi
    done
}

##\brief Transform lower case letters into upper case letters.
## 
##  Transform lower case letters into upper case letters.
##
##   \param $* list of 0 or more strings to be converted
##
makl_upper ()
{
   ${ECHO} $* | tr "[a-z]" "[A-Z]"
}

##\brief Cleanup run-time directory.
##
##  Cleanup run-time directory ${makl_run_dir}.
##
makl_cleanup_rundir ()
{
    [ -z `makl_get "__noclean__"` ] || return 
    rm -rf ${makl_run_dir}
}

##\brief Clean MaKL exit
##
## Exit from MaKL cleanly with return code $1
##
##  \param $1 - the return code
## 
makl_die ()
{
    makl_cleanup_rundir
    exit $1
}

##\brief Yes/No Question.
##
##  Write question \e $1 to the terminal and wait for the user to answer.
##
##   \param $1 - question string
##   \return 0 if [yY] was typed, 1 if [nN].
##
makl_yesno ()
{
    ${ECHO} -n "$1 " 
    
    while [ /bin/true ]; do 
        read answer
        case ${answer} in
            [Yy])
                return 0
                ;;
            [nN])
                return 1
                ;;
            *)
                ${ECHO} -n "please say [yY] or [nN]: "
                ;;
        esac
    done
}

##\brief Check validity of a mode string.
##
##  Check whether \e $1 is a valid mode string (3 octal digits).
##
##  \param $1 - mode string
##  \return 0 if valid, 1 otherwise
##
makl_is_mode ()
{
    ${ECHO} $1 | grep '^[0-7][0-7][0-7]$' 1>/dev/null 2>/dev/null

    return $?
}

## \brief Generate default directories.
##
##  Generate default installation directories starting from prefix \e $1.
##  Note: should match etc/map.mk configuration
## 
##  \param $1 - prefix
##
makl_set_dirs()
{
    makl_set_var "DESTDIR"  $1 1
    makl_set_var "BINDIR"   $1/bin 1
    makl_set_var "SBINDIR"  $1/sbin 1
    makl_set_var "CONFDIR"  $1/etc 1
    makl_set_var "INCDIR"   $1/include 1
    makl_set_var "LIBDIR"   $1/lib 1
    makl_set_var "SHLIBDIR" $1/lib 1
    makl_set_var "LIBEXDIR" $1/libexec 1
    makl_set_var "VARDIR"   $1/bin 1
    makl_set_var "SHAREDIR" $1/bin 1
    makl_set_var "MANDIR"   `makl_get_var_mk "SHAREDIR"`/man 1
    makl_set_var "DOCDIR"   `makl_get_var_mk "DOCDIR"`/doc 1
}
