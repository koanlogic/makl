#
# $Id: makl_utils,v 1.21 2005/12/01 12:29:03 stewy Exp $
#

##\brief Set the package name.
##
##  Set the package name to \e $1.
##
##  \param $1 package name
##  
makl_pkg_name ()
{
    [ $1 ] || makl_err 1 "makl_pkg_name(): undefined package name!"

    makl_dbg "setting package name to $1"

    makl_set "__package__" "$1"
}

##\brief Set the package version.
##
##  Set the package version to \e $1.
##  [format: "X.Y.Z", where X, Y and Z are digits]
##  If no argument is supplied, a file named VERSION in the base 
##  directory containing the version is expected. 
##  The package name must already be defined by \e makl_pkg_name().
##
##  \param $1 package version (optional)
##  
makl_pkg_version ()
{
    file="VERSION"
    pkg=`makl_get "__package__"`

    [ -z ${pkg} ] && \
        makl_err 1 "makl_pkg_version(): makl_pkg_name must be defined first!"

    [ -f ${file} ] && [ -r ${file} ] && \
        ver=`cat ${file} | sed 's/[\ 	]*$//'`	#remove trailing whitespace

    [ $? = 0 ] || ver=$1

    echo ${ver} | grep '^[0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*$' 1> /dev/null
    [ $? = 0 ] || makl_err 2 "makl_pkg_version(): version must have format 'X.Y.Z'" \
						     "where X, Y and Z are digits."

    makl_set_var "`makl_upper ${pkg}`_VERSION" ${ver} 1
}

##\brief Print the OS name.
## 
##  Print a brief string representing the operating system type and version.
##
makl_os_name ()
{
    uname -rs | tr '[A-Z]' '[a-z]' | sed -e 's/ //'
}

##\brief Write a message and exit.
##
##  Print the supplied error string to stderr and bail out with the given 
##  exit code.
## 
##   \param $1 exit code
##   \param $2 error string
##
makl_err ()
{
    exit_code=$1
    shift

    echo 1>&2 "[err] $*"
    makl_cleanup_rundir
    exit ${exit_code}
}

##\brief Print a debug message. 
##
##  Print the supplied debug message to stderr if "makl_debug" variable is set
##  to "true", "yes", "on" or '1'.
##
##   \param $1 debug string
##
makl_dbg ()
{
    case ${makl_debug} in
        [Yy][Ee][Ss]|[Tt][Rr][Uu][Ee]|[Oo][Nn]|1)
            echo 1>&2 "[dbg] $*"
            ;;
    esac
}

##\brief Print a warning message.
##
##  Print the supplied warning message to stderr.
##  
##   \param $1 warning string
##
makl_warn ()
{
    echo 1>&2 "[wrn] $*"
}

##\brief Print global variables.
##
##  Print MaKL global variables in use to stderr if 'makl_debug' is set.
##
makl_dbg_globals ()
{
    makl_dbg "MAKL_DIR: ${MAKL_DIR}"
    makl_dbg "makl_run_dir: ${makl_run_dir}"
    makl_dbg "makl_conf_h: ${makl_conf_h}"
    makl_dbg "makl_makefile_conf: ${makl_makefile_conf}"
}

##\brief Transform lower case letters into upper case letters.
## 
##  Transform lower case letters into upper case letters.
##
##   \param $* list of 0 or more strings to be converted
##
makl_upper ()
{
   echo $* | tr "[a-z]" "[A-Z]"
}

##\brief Cleanup run-time directory.
##
##  Cleanup run-time directory ${makl_run_dir}.
##
makl_cleanup_rundir ()
{
    [ -z `makl_get "__noclean__"` ] || return 
    rm -rf ${makl_run_dir}
}

##\brief Yes/No Question.
##
##  Write question \e $1 to the terminal and wait for the user to answer.
##
##   \param $1 - question string
##   \return 0 if [yY] was typed, 1 if [nN].
##
makl_yesno ()
{
    echo -n "$1 " 
    
    while [ /bin/true ]; do 
        read answer
        case ${answer} in
            [Yy])
                return 0
                ;;
            [nN])
                return 1
                ;;
            *)
                echo -n "please say [yY] or [nN]: "
                ;;
        esac
    done
}

##\brief Check validity of a mode string.
##
##  Check whether \e $1 is a valid mode string (3 octal digits).
##
##  \param $1 - mode string
##  \return 0 if valid, 1 otherwise
##
makl_is_mode ()
{
    echo $1 | grep '^[0-7][0-7][0-7]$' 1>/dev/null 2>/dev/null

    return $?
}
